<!DOCTYPE html>
<html lang="en">

<head>
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }

        ul {
            list-style-type: none;
            margin: 0px;
            padding: 0px;
        }

        .Verital {

            list-style-type: none;
            margin: 0px;
            padding: 0px;
            width: 200px;
            height: 1300px;
            background-color: darkcyan;

        }

        .index a {
            display: block;
            color: black;
            padding: 8px 16px;
            text-decoration: none;
            border: solid 1px black;
        }

        .index a:hover {
            color: white;
            background-color: goldenrod;
        }

        .index a:active {
            color: chartreuse;
            background-color: goldenrod;
        }

        .nav {
            margin-top: -12px;
            overflow: auto;
            width: 200px;
            height: 600px;
            float: left;
            position: fixed;





        }

        .horizotral a {
            text-decoration: none;
            color: white;


        }

        .horizotral {
            display: inline;
            padding: 16px;
        }

        .Hnav {
            background-color: black;
            width: 100%;
            height: 20px;
            padding: 25px;
            margin: 0px;
            position: fixed;
            top: -3px;



        }

        .horizotral a:hover {
            color: white;
            background-color: darkgoldenrod;
            padding: 27px;
        }


        h1 {
            margin-top: 80px;
            display: flex;
            justify-content: end;
            padding: 5px;
            margin-right: 40px;

        }

        #pra1,
        #pra2,
        #pra3,
        #pra4,
        #pra5,
        #pra6,
        #pra7,
        #pra8,
        #pra9,
        #pra10,
        #pra11,
        #pra12,
        #pra13,
        #pra14,
        #pra15,
        #pra16,
        #pra17,
        #pra18,
        #pra19,
        #pra20,
        #pra21,
        #pra22,
        #pra23,
        #pra24,
        #pra25 {
            padding: 10px;
            margin-left: 220px;
            font-size: larger;
            margin-right: 30px;

        }

        #c2,
        #c3,
        #c4,
        #c5,
        #c6,
        #c7,
        #c8,
        #c9,
        #c10,
        #c111,
        #c12,
        #c13,
        #c14,
        #c15,
        #c16,
        #c17,
        #c18,
        #c19,
        #c20,
        #c21,
        #c22,
        #c23,
        #c24,
        #c25 {
            margin-top: -0px;

        }
    </style>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>navbar</title>
</head>

<body>
    <div class="Hnav">
        <ul>
            <li class="horizotral"><a href="index.html">Basic computer</a></li>
            <li class="horizotral"><a href="#Cloud computing">Cloud Computing</a></li>
            <li class="horizotral"><a href="computer_network.html">Computer Network</a></li>
            <li class="horizotral"><a href="#Python">Python</a></li>
            <li class="horizotral"><a href="#PHP">PHP</a></li>
            <li class="horizotral"><a href="software_enginnering.html">Software Enginnering</a></li>
        </ul>
    </div>
    <div class="main">

        <div class="nav">
            <ul class="Verital">
                <li class="index"><a href="#c1">Cloud computing</a></li>
                <li class="index"><a href="#c1">Evolution of cloud computing</a></li>
                <li class="index"><a href="#c2">Characteristics of cloud computing</a></li>
                <li class="index"><a href="#c3">Apllicationg of cloud computing</a></li>
                <li class="index"><a href="#c4">Bendfits and challenge of clud computing</a></li>
                <li class="index"><a href="#c5">Service and Deployment models</a></li>
                <li class="index"><a href="#c6">Major cloud service providers</a></li>
                <li class="index"><a href="#c7">Service Level Agreement</a></li>
                <li class="index"><a href="#c8">Types of SLAs</a></li>
                <li class="index"><a href="#c9">SLA life cycle</a></li>
                <li class="index"><a href="#c10">SLA managemnt process</a></li>
                <li class="index"><a href="#c11">Vertualization</a></li>
                <li class="index"><a href="#c12">Advantage/Benefits of virtualization</a></li>
                <li class="index"><a href="#c13">Hypervisors in cloud computing</a></li>
                <li class="index"><a href="#c14">Cloud Security</a></li>
                <li class="index"><a href="#c15">Data Security & privacy issues</a></li>
                <li class="index"><a href="#c16">Legal issues in cloud computing</a></li>
                <li class="index"><a href="#c17">Cloud Storage</a></li>
                <li class="index"><a href="#c18">Challenges of cloud storage</a></li>
                <li class="index"><a href="#c19">Storage Area network</a></li>
                <li class="index"><a href="#c20">Scheduling in cloud</a></li>
                <li class="index"><a href="#c21">Cloud scheduling problelms</a></li>
                <li class="index"><a href="#c22">Different types of Schedulijng in cloud computing</a></li>
                <li class="index"><a href="#c23">Scheduling for independent and dependent tasks</a></li>
                <li class="index"><a href="#c24">Static and Dynamic scheduling</a></li>
            </ul>
        </div>

        <div>
            <h1 id="c1"> Introduction to Software Engineering</h1>
            <hr>
            <p id="pra1">
                Software engineering is a discipline that involves the design, development, testing, and maintenance of
                software systems. It is the process of applying engineering principles and practices to the creation and
                maintenance of high-quality software.
                Software engineering encompasses a wide range of activities, including requirements analysis, software
                design, programming, testing, documentation, and maintenance. It also involves the use of tools,
                techniques, and methodologies to manage the software development process, such as software development
                life cycle (SDLC) models, agile methodologies, and project management techniques.
                The goal of software engineering is to develop high-quality software that meets the needs of its users,
                is reliable and efficient, and is delivered on time and within budget. To achieve this goal, software
                engineers must have a strong understanding of computer science, programming languages, software design
                principles, and project management.
                Software engineering is a rapidly growing field, with demand for skilled software engineers increasing
                each year. Software engineers can work in a variety of industries, including technology, healthcare,
                finance, and entertainment. They can also work in a variety of roles, such as software developers,
                project managers, quality assurance analysts, and software architects.

                <hr>
        </div>
        <div>
            <h1 id="c2">Concept of systems: Types of systems : open, closed, static and dynamic systems.</h1>
            <hr>
            <p id="pra2">

                In general, a system is a group of interconnected and interdependent elements or components that work
                together to achieve a specific goal. Systems can be found in many different domains, such as
                engineering, biology, economics, and computer science.
                There are several types of systems, including:
                1. Open Systems: Open systems interact with their environment, exchanging matter, energy, or
                information. They receive input from their environment, transform it, and then output it back into the
                environment. Examples of open systems include living organisms, ecosystems, and some types of software
                applications.
                2. Closed Systems: Closed systems do not interact with their environment, or their interaction is
                limited. They do not exchange matter, energy, or information with their environment. Closed systems are
                rare in practice, but examples include sealed thermos flasks and some types of software applications
                that do not interact with external systems.
                3. Static Systems: Static systems do not change over time. They are characterized by stability and lack
                of movement or change. Examples of static systems include an unchanging painting or a printed book.
                4. Dynamic Systems: Dynamic systems change over time. They are characterized by movement, evolution, and
                adaptation. Examples of dynamic systems include living organisms, evolving ecosystems, and some types of
                software applications.
                It is worth noting that these types of systems are not mutually exclusive, and some systems can exhibit
                characteristics of multiple types of systems. Additionally, the classification of a system as open,
                closed, static, or dynamic can be subjective and depend on the context and purpose of the system
                analysis.

                <br> <br>
            </p>
        </div>
        <hr>
        <div>
            <h1 id="c3">Introduction, Programmes v/s Software Products </h1>
            <hr>
            <p id="pra3">
                Introduction:
                Software refers to computer programs and the associated data and documentation that provide the
                instructions for telling a computer what to do and how to do it. Software is used for a wide range of
                applications, from operating systems and databases to productivity software and video games.
                Programs vs. Software Products:
                A program is a set of instructions that tell a computer what to do. It is typically created by a single
                person or a small team of developers and is often designed to solve a specific problem or perform a
                specific task. Programs are usually intended for use by a limited audience and are not typically sold
                commercially.
                Software products, on the other hand, are typically created by larger teams of developers and are
                designed for a wider audience. They are commercial products that are sold to customers, and they often
                undergo extensive testing and quality assurance processes before being released. Software products are
                designed to be scalable and adaptable to a range of use cases, and they often include features such as
                user interfaces, documentation, and technical support.
                While programs and software products share many similarities, they differ in terms of their intended
                audience, development process, and level of complexity. Programs are typically smaller and less complex
                than software products, and they are often created by individual developers or small teams. Software
                products, on the other hand, are more complex and are typically created by larger teams of developers
                who work together to create a product that can be used by a wide audience.
                <br> <br>
            </p>

        </div>
        <hr>
        <div>
            <h1 id="c4">Computer Programming, High-level Language Programming, Control flow based Design, Data Structure
                Oriented Design,
            </h1>
            <hr>
            <p id="pra4">
                Computer Programming:
                Computer programming is the process of designing, writing, testing, and maintaining computer software.
                It involves using a programming language to create instructions that a computer can understand and
                execute. Programming is used to create a wide range of applications, from simple scripts to complex
                software systems.
                High-Level Language Programming:
                High-level language programming refers to the use of programming languages that are designed to be more
                human-readable and easier to use than low-level languages, such as assembly language. High-level
                languages provide more abstraction from the underlying hardware and allow developers to focus on the
                logic of their programs rather than the details of how the computer executes them. Examples of
                high-level languages include Python, Java, and C++.
                Control Flow Based Design:
                Control flow based design is a software design technique that focuses on the control flow of a program.
                Control flow refers to the order in which the instructions of a program are executed. Control flow based
                design involves designing a program by breaking it down into smaller parts and then designing the
                control flow of each part. This approach can help to make programs more modular and easier to understand
                and maintain.
                Data Structure Oriented Design:
                Data structure oriented design is a software design technique that focuses on the data structures used
                by a program. Data structures are used to organize and store data in a program, and data structure
                oriented design involves designing a program by first identifying the data structures that will be used
                and then designing the program around those structures. This approach can help to make programs more
                efficient and easier to maintain. Common data structures include arrays, linked lists, and hash tables.
                <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c5"> Software Life Cycle Models</h1>
            <hr>
            <p id="pra5">
                Software life cycle models are frameworks that describe the stages involved in the development,
                maintenance, and eventual retirement of software. These models provide a structured approach to software
                development and help ensure that software projects are completed on time, within budget, and to the
                desired quality standards.
                . <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c6">Waterfall Model, Prototyping Model, Evolutionary Model, Spiral Model</h1>
            <hr>
            <p id="pra6">
                Waterfall Model:
                The waterfall model is a linear, sequential approach to software development that consists of several
                distinct stages, including requirements gathering, design, implementation, testing, and maintenance.
                Each stage must be completed before moving on to the next, and changes made in one stage can be
                difficult and expensive to implement in later stages. The waterfall model is well-suited for projects
                with well-defined requirements, a clear project scope, and a fixed timeline.
                Prototyping Model:
                The prototyping model is an iterative approach to software development that involves building and
                refining prototypes of the software until the final product is completed. This model is often used when
                the requirements are unclear or changing and when the software needs to be quickly developed and tested.
                The prototyping model allows for early user feedback and can help identify potential issues early in the
                development process.
                Evolutionary Model:
                The evolutionary model is an iterative and incremental approach to software development that involves
                developing the software in stages, with each stage building on the previous one. The evolutionary model
                is well-suited for projects with changing requirements, and it allows for flexibility and adaptability
                as the project progresses. This model is often used for large, complex projects with a long development
                timeline.
                Spiral Model:
                The spiral model is a risk-driven approach to software development that combines elements of both the
                waterfall model and the prototyping model. It involves iterative cycles of planning, design,
                implementation, and evaluation, with each cycle building on the previous one. The spiral model is
                well-suited for projects with high levels of risk or uncertainty, as it allows for continuous risk
                assessment and mitigation throughout the development process.
                Each of these models has its own strengths and weaknesses, and the choice of model depends on the
                specific needs of the software project. The software life cycle model chosen for a project can have a
                significant impact on its success, so it is important to choose a model that is appropriate for the
                project's goals, timeline, and resources.

            </p>

        </div>

        <hr>
        <div>
            <h1 id="c7">Introduction to angle methodology</h1>
            <hr>
            <p id="pra7">
                The Agile methodology is an iterative and incremental approach to software development that focuses on
                delivering working software quickly and efficiently, while also allowing for flexibility and
                adaptability throughout the development process. The Agile methodology is based on the principles
                outlined in the Agile Manifesto, which emphasizes collaboration, customer satisfaction, and continuous
                improvement. <br>

            </p>

        </div>

        <hr>
        <div>
            <h1 id="c8">Software Planning</h1>
            <hr>
            <p id="pra8">
                Software planning is the process of defining the scope, objectives, and requirements of a software
                project, and developing a plan to meet those goals within a specified timeline and budget. The planning
                phase is critical to the success of a software project, as it sets the foundation for the entire
                development process.
                The software planning process typically involves the following steps:
                1. Defining project goals and objectives: This involves determining the purpose and scope of the
                software project, and identifying the specific goals and objectives that it needs to achieve.
                2. Identifying stakeholders: This involves identifying all stakeholders who are involved in or affected
                by the software project, including users, customers, developers, testers, and project managers.
                3. Gathering requirements: This involves collecting and documenting the functional and non-functional
                requirements of the software project, including user stories, use cases, and other specifications.
                4. Developing a project plan: This involves developing a detailed plan for the software project,
                including timelines, budgets, resources, and risk management strategies.
                5. Creating a project schedule: This involves creating a detailed schedule that outlines the tasks,
                milestones, and deliverables for each phase of the project.
                6. Estimating resources and costs: This involves estimating the resources, costs, and timelines required
                to complete each phase of the project, and identifying any potential risks or challenges that may arise.
                7. Creating a project team: This involves selecting and assembling a team of developers, testers, and
                other professionals who will be responsible for completing the software project.
                . <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c9">Responsibilities of Software Project Manager</h1>
            <hr>
            <p id="pra9">
                The Software Project Manager (SPM) is responsible for planning, organizing, and managing software
                projects from start to finish, and ensuring that they are completed on time, within budget, and to the
                desired quality standards. The SPM is responsible for the following key responsibilities:
                1. Project Planning: The SPM is responsible for developing a project plan that outlines the scope,
                objectives, and requirements of the software project, and identifies the resources, timelines, and
                budget required to complete it.
                2. Resource Management: The SPM is responsible for managing the resources required for the project,
                including human resources, hardware, software, and other materials needed for the project.
                3. Risk Management: The SPM is responsible for identifying and mitigating risks that may impact the
                project, and developing contingency plans to address them if they arise.
                4. Team Management: The SPM is responsible for managing the project team, including hiring, training,
                and assigning tasks to team members, and ensuring that they are working together effectively and
                efficiently.
                5. Project Monitoring and Control: The SPM is responsible for monitoring the progress of the project and
                making adjustments as needed to ensure that it is on track to meet its objectives.
                6. Stakeholder Management: The SPM is responsible for managing the relationships with stakeholders,
                including customers, users, vendors, and other project partners, and ensuring that their needs and
                expectations are being met.
                7. Quality Assurance: The SPM is responsible for ensuring that the software project meets the desired
                quality standards, and that it is free of errors and defects.
                <br>

            </p>

        </div>

        <hr>
        <div>
            <h1 id="c10">Metrics for Project Size Estimation- LOC(Lines of Code), Function Point Metric
            </h1>
            <hr>
            <p id="pra10">
                There are several metrics used for project size estimation in software development. Two commonly used
                metrics are Lines of Code (LOC) and Function Point Metric (FPM).
                1. Lines of Code (LOC): LOC is a simple metric that estimates the size of a software project by counting
                the number of lines of code in the software. This metric is widely used because it is easy to understand
                and calculate. However, it has some limitations, such as being language-specific and not accounting for
                the complexity of the code.
                2. Function Point Metric (FPM): FPM is a more sophisticated metric that measures the functionality
                provided by a software system, regardless of the language used to develop it. This metric calculates the
                size of a software project based on the number of input, output, inquiry, and data storage functions it
                provides. This metric is more accurate than LOC, as it accounts for the complexity of the code and the
                functionality provided by the software system.
                <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c11">Project estimation Techniques- Using COCOMO Model</h1>
            <hr>
            <p id="pra11">
                The Constructive Cost Model (COCOMO) is a popular software cost estimation model that was developed by
                Barry Boehm in the late 1970s. COCOMO provides a framework for estimating the effort, time, and cost
                required to develop a software project. There are three variants of the COCOMO model:
                1. Basic COCOMO: This model is a simple, high-level estimation technique that uses size and complexity
                factors to estimate the effort required for a software project. It is suitable for small to medium-sized
                projects and is based on the following formula:
                Effort = a * (KLOC) ^ b
                where a and b are constants and KLOC represents the estimated size of the software project in thousands
                of lines of code.
                2. Intermediate COCOMO: This model is a more detailed estimation technique that takes into account the
                characteristics of the software project, such as the number of users, the complexity of the system, and
                the development environment. It is suitable for medium to large-sized projects and is based on the
                following formula:
                Effort = a * (KLOC) ^ b * [EAF]
                where EAF is the effort adjustment factor, which takes into account the characteristics of the software
                project.
                3. Detailed COCOMO: This model is the most detailed estimation technique and takes into account a wide
                range of factors, such as the complexity of the software architecture, the development team's
                experience, and the development tools and techniques being used. It is suitable for large and complex
                software projects and is based on the following formula:
                Effort = (a * (KLOC) ^ b) * [EM] * [EAF]
                where EM is the effort multiplier, which takes into account the development team's experience and the
                development tools and techniques being used.
                In order to use the COCOMO model for project estimation, the development team needs to gather data on
                the size and complexity of the software project, as well as the characteristics of the development
                environment. This data is used to calculate the effort required for the project, as well as the project
                schedule and cost.

                <br>

            </p>

        </div>

        <hr>
        <div>
            <h1 id="c12">Requirement Analysis and Specification</h1>
            <hr>
            <p id="pra12">
                Requirement analysis and specification is a critical phase in software development that involves
                gathering, analyzing, documenting, and validating the requirements of a software system.
                The main objectives of requirement analysis and specification are to:
                1. Understand the needs of the users and stakeholders: The first step in requirement analysis is to
                identify the users and stakeholders of the software system and understand their needs and requirements.
                2. Define the scope of the software system: The second step is to define the scope of the software
                system and identify the features and functions that need to be included.
                3. Document the requirements: The third step is to document the requirements in a clear and concise
                manner, using a variety of techniques such as use cases, user stories, and functional and non-functional
                requirements.
                4. Validate the requirements: The final step is to validate the requirements to ensure that they are
                complete, consistent, and accurate, and that they meet the needs of the users and stakeholders.
                The process of requirement analysis and specification typically involves the following steps:
                1. Requirements gathering: This involves collecting information from users, stakeholders, and other
                sources to identify the requirements of the software system.
                2. Requirements analysis: This involves analyzing the requirements to identify any inconsistencies or
                conflicts, and to identify the most important features and functions.
                3. Requirements documentation: This involves documenting the requirements using various techniques such
                as use cases, user stories, and functional and non-functional requirements.
                4. Requirements validation: This involves reviewing the requirements to ensure that they are complete,
                consistent, and accurate, and that they meet the needs of the users and stakeholders.

            </p>

        </div>

        <hr>
        <div>
            <h1 id="c13">Software Requirement Specifications (SRS)</h1>
            <hr>
            <p id="pra13">
                Software Requirement Specification (SRS) is a document that describes the requirements and
                specifications of a software system. The SRS document serves as a blueprint for the development team,
                providing a detailed description of the software system's functionality, features, and behaviour. The
                purpose of the SRS is to ensure that all stakeholders have a clear understanding of the software
                system's requirements, and that the development team has a clear roadmap for software development.
                The SRS document typically includes the following sections:
                1. Introduction: This section provides an overview of the software system and the purpose of the SRS
                document.
                2. Scope: This section defines the boundaries of the software system and identifies the features and
                functions that will be included in the software system.
                3. Functional Requirements: This section describes the functional requirements of the software system,
                including the inputs, processing, and outputs of the system.
                4. Non-functional Requirements: This section describes the non-functional requirements of the software
                system, such as performance, reliability, and security.
                5. User Interface Requirements: This section describes the requirements for the user interface of the
                software system, including the layout, navigation, and user interaction.
                6. System Architecture: This section describes the system architecture of the software system, including
                the hardware and software components and their interactions.
                7. Dependencies: This section identifies any dependencies of the software system, such as third-party
                libraries or external systems.
                8. Assumptions and Constraints: This section identifies any assumptions and constraints that have been
                made during the development of the SRS.
                9. Acceptance Criteria: This section describes the criteria that will be used to determine whether the
                software system meets the requirements.
                The SRS document is an important part of the software development process, as it serves as a guide for
                the development team, as well as a communication tool for all stakeholders. It is important to ensure
                that the SRS document is well-written, clear, and comprehensive, in order to ensure the success of the
                software project.
                <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c14">Characteristics of good SRS</h1>
            <hr>
            <p id="pra14">
                A good Software Requirement Specification (SRS) document should have the following characteristics:
                1. Clear and concise: The document should be easy to read and understand, with a clear and concise
                writing style.
                2. Complete: The SRS document should include all the requirements and specifications for the software
                system, with no omissions or ambiguities.
                3. Consistent: The requirements and specifications should be consistent throughout the document, with no
                contradictions or conflicts.
                4. Testable: The requirements should be verifiable and testable, with clear acceptance criteria that can
                be used to determine whether the software system meets the requirements.
                5. Traceable: Each requirement should be traced back to the source, such as a user need or a functional
                requirement, to ensure that it is necessary and valid.
                6. Feasible: The requirements should be feasible within the constraints of the project, such as the
                budget, schedule, and technology limitations.
                7. Prioritized: The requirements should be prioritized based on their importance and value to the users
                and stakeholders, with higher-priority requirements given more attention during development.
                8. Consistent with standards: The requirements should be consistent with relevant industry standards and
                best practices, such as security standards or usability guidelines.
                9. Modifiable: The SRS document should be easy to modify and update as requirements change or new
                information becomes available.
                10. Approved: The SRS document should be approved by all relevant stakeholders, including the
                development team, the project manager, and the users, to ensure that everyone is in agreement about the
                requirements and specifications of the software system.

                <br>
            </p>

        </div>


        <hr>
        <div>
            <h1 id="c15">Software Design and Implementation</h1>
            <hr>
            <p id="pra15">
                Software design and implementation are the processes of creating a software solution that meets the
                requirements and specifications outlined in the Software Requirement Specification (SRS) document.
                Software Design: Software design is the process of creating a plan for a software solution that meets
                the requirements outlined in the SRS document. During the design process, the development team
                determines the software architecture, data structures, algorithms, and interfaces needed to implement
                the software solution. The goal of software design is to create a blueprint for the software solution
                that can be used by the development team during the implementation phase.
                Software Implementation: Software implementation is the process of turning the software design into a
                working software solution. During the implementation phase, the development team writes the code and
                creates the data structures and algorithms defined in the software design. The implementation phase also
                involves testing and debugging the software solution to ensure that it meets the requirements outlined
                in the SRS document.
                <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c16">Software Design Cohesion and Coupling</h1>
            <hr>
            <p id="pra16">
                In software design, cohesion and coupling are important concepts that describe the quality of the design
                of software modules or components.
                Cohesion: Cohesion refers to the degree to which the elements within a module or component are related
                to each other and work together to achieve a single, well-defined purpose or task. In other words, a
                cohesive module or component should contain elements that are closely related and work together to
                perform a specific function or set of functions. High cohesion is desirable in software design because
                it makes the module or component easier to understand, maintain, and modify. On the other hand, low
                cohesion can lead to software that is difficult to understand and modify.

                Coupling: Coupling refers to the degree to which two or more modules or components depend on each other.
                In other words, coupling describes the level of interdependence between modules or components. High
                coupling means that modules or components are tightly connected and depend heavily on each other, while
                low coupling means that modules or components are loosely connected and can be modified or replaced
                without affecting other modules or components. Low coupling is desirable in software design because it
                makes the software more modular, flexible, and easier to maintain and modify. On the other hand, high
                coupling can lead to software that is difficult to understand, modify, and maintain.
                <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c17">Software design Approaches- Function Oriented Design (Data flow diagrams, Data dictionary</h1>
            <hr>
            <p id="pra17">
                Function-Oriented Design (FOD) is a software design approach that focuses on the functions or processes
                that a software system must perform. In FOD, a software system is modeled as a series of functional
                transformations that take input data and produce output data. FOD is often used in conjunction with Data
                Flow Diagrams (DFD) and Data Dictionaries.
                Data Flow Diagrams: Data Flow Diagrams are graphical representations of the flow of data through a
                software system. A DFD consists of a set of interconnected nodes, where each node represents a function
                or process that transforms input data into output data. The arrows connecting the nodes represent the
                flow of data between functions. DFDs are useful for identifying the inputs, outputs, and transformations
                that are needed to implement a software system.
                Data Dictionary: A Data Dictionary is a structured repository of information about the data elements
                used in a software system. The Data Dictionary includes information such as the data type, length, and
                format of each data element, as well as any validation rules or constraints that apply to the data. The
                Data Dictionary is used to ensure that all data elements are used consistently throughout the software
                system, and that data is properly validated and formatted.
                In Function-Oriented Design, the software system is decomposed into a series of functions or processes,
                each of which performs a specific transformation on input data. The Data Flow Diagrams are used to
                identify the inputs, outputs, and transformations of each function, and the Data Dictionary is used to
                ensure that data is used consistently and correctly throughout the software system. FOD is a useful
                approach for designing software systems that perform well-defined functions, and for ensuring that the
                inputs and outputs of each function are properly defined and understood.

                <br>

            </p>

        </div>

        <hr>
        <div>
            <h1 id="c19">Decision Trees and tables, Object Oriented Design, Structured Coding Techniques, Coding Styles,
                documentation</h1>
            <hr>
            <p id="pra19">
                Decision Trees and Tables: Decision trees and tables are techniques used in software design to represent
                complex decision-making processes. A decision tree is a graphical representation of a decision-making
                process, where each node in the tree represents a decision or action, and the edges connecting the nodes
                represent the possible outcomes or results of each decision. Decision tables, on the other hand, are
                tabular representations of decision-making processes, where each row in the table represents a set of
                conditions, and each column represents a possible action or outcome. Decision trees and tables are
                useful for designing software systems that involve complex decision-making processes, and for ensuring
                that all possible outcomes and actions are properly considered.
                Object-Oriented Design: Object-oriented design is a software design approach that focuses on creating
                objects, which are self-contained units of code that contain both data and the functions that manipulate
                that data. Object-oriented design emphasizes encapsulation, inheritance, and polymorphism, which are
                techniques for creating objects that are modular, flexible, and reusable. Object-oriented design is
                useful for creating software systems that are easy to modify and extend, and that can be easily adapted
                to changing requirements.
                Structured Coding Techniques: Structured coding techniques are a set of coding conventions and practices
                that emphasize modularity, readability, and maintainability. Structured coding techniques include
                techniques such as top-down design, structured programming, and stepwise refinement, which are all
                designed to create code that is easy to understand, modify, and maintain. Structured coding techniques
                are particularly useful for creating large, complex software systems, where modularity and
                maintainability are essential.
                Coding Styles: Coding styles are conventions and guidelines for writing code that promote consistency
                and readability. Coding styles include things like indentation, naming conventions, commenting, and
                variable declaration, which are all designed to make code easier to read and understand. Consistent
                coding styles are particularly important in large software projects, where many developers may be
                working on the same codebase.
                Documentation: Documentation refers to the process of creating and maintaining written or visual
                materials that describe the software system. Documentation can include things like user manuals,
                technical specifications, design documents, and code comments. Good documentation is essential for
                creating software systems that are easy to understand, modify, and maintain, and for ensuring that the
                system is properly documented for future reference.

                <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c20">Software Testing</h1>
            <hr>
            <p id="pra20">
                Software testing is the process of evaluating a software system or application to identify defects,
                errors, or other issues that may affect its performance, functionality, or usability. The main purpose
                of software testing is to ensure that the software system or application meets the requirements and
                specifications, and that it functions correctly under all conditions.
                There are different types of software testing, including:
                1. Unit Testing: This is the process of testing individual components or modules of the software system
                to ensure that they function correctly.
                2. Integration Testing: This is the process of testing the integration of individual components or
                modules of the software system to ensure that they function correctly when combined.
                3. System Testing: This is the process of testing the entire software system to ensure that it meets the
                requirements and specifications, and that it functions correctly under all conditions.
                4. Acceptance Testing: This is the process of testing the software system or application to ensure that
                it meets the user requirements and specifications, and that it functions correctly under normal
                operating conditions.
                5. Regression Testing: This is the process of testing the software system or application to ensure that
                any changes or modifications have not affected its functionality or performance.
                6. Performance Testing: This is the process of testing the software system or application to ensure that
                it can handle the expected load and usage, and that it performs well under all conditions.
                7. Security Testing: This is the process of testing the software system or application to ensure that it
                is secure and protected against any potential security threats or vulnerabilities.

                <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c21">Verification v/s Validations</h1>
            <hr>
            <p id="pra21">
                Verification and validation are two important processes in software testing that are often used
                interchangeably, but they have distinct meanings.
                Verification is the process of checking whether the software system or application meets its design
                specifications and requirements. It involves reviewing and testing the software code to ensure that it
                conforms to the specified design and requirements.
                Validation, on the other hand, is the process of checking whether the software system or application
                meets the user requirements and expectations. It involves testing the software in real-world scenarios
                to ensure that it performs as expected and meets the user needs.
                In simpler terms, verification is about checking whether the software is built correctly, while
                validation is about checking whether the right software has been built.
                For example, in a project to build a calculator application, verification would involve checking whether
                the application has all the required buttons and mathematical operations, and whether the calculations
                are performed correctly. Validation would involve testing the application with real users to ensure that
                it is easy to use and that it meets the user's expectations.
                Both verification and validation are important processes in software testing, as they help to ensure the
                quality and reliability of the software system or application. They are often performed in parallel to
                ensure that the software is both built correctly and meets the user requirements.

                <br>
            </p>

        </div>

        <hr>
        <div>
            <h1 id="c22">Black Box Testing, White Box Testing</h1>
            <hr>
            <p id="pra22">
                Black box testing and white box testing are two different methods of software testing.
                Black box testing is a testing method where the tester evaluates the software system or application from
                an external point of view, without knowledge of its internal workings or code. The tester tests the
                software system or application against the requirements and specifications, without any knowledge of how
                the software is designed or implemented. The focus of black box testing is on the functionality and
                behavior of the software, rather than its internal structure.
                White box testing, on the other hand, is a testing method where the tester has knowledge of the internal
                workings or code of the software system or application. The tester tests the software system or
                application by examining the code and logic, to ensure that it functions correctly and meets the
                requirements and specifications. The focus of white box testing is on the internal structure and logic
                of the software, rather than its external behavior.
                In simpler terms, black box testing is like testing a car by driving it, without any knowledge of how
                the engine or transmission works, while white box testing is like testing a car by examining the
                internal components and mechanisms, to ensure that they function correctly.

                <br>

            </p>

        </div>
        <hr>
        <div>
            <h1 id="c23">Configuration management
            </h1>
            <hr>
            <p id="pra23">
                Configuration management is the process of identifying, organizing, and controlling changes to a
                software system or application throughout its lifecycle. It is an important aspect of software
                engineering that helps to ensure that software is developed, tested, and deployed consistently and
                efficiently.
                The main goal of configuration management is to manage and track changes to software systems and
                applications, including changes to software code, documents, and other artifacts. Configuration
                management involves the use of tools and techniques to manage and track changes to software systems and
                applications, including version control, release management, and change management.

                <br>
            </p>

        </div>

        <hr>


    </div>

</body>

</html>